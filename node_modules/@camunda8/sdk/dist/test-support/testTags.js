"use strict";
/**
 * Test environment selection utilities (Matrix + Exclude model)
 *
 * BREAKING CHANGE: Previous TagFilter / matrix(filterObjectReturningBoolean) semantics removed.
 * New primary APIs:
 *   - matrix({ include: { versions: ['8.8','8.7'], deployments: ['saas','self-managed'] }, exclude: [{ version: '8.8', deployment: 'self-managed' }] })
 *   - allowAny([{ version: '8.7' }, { version: '8.8', deployment: 'saas' }])
 *   - matrix(predicate) -> returns boolean for use with Vitest test.if(matrix(...))
 *
 * Semantics:
 *   matrix(): Produces the cartesian product of provided include dimension arrays. Any dimensions omitted are treated as wildcards (not expanded).
 *             Exclusion patterns (partial matches) remove matching tuples.
 *   allowAny(): Returns true if the current environment matches ANY provided partial pattern.
 *   matrix(): Just invokes the predicate with the current environment and returns a boolean (thin wrapper for clarity / future debug hooks).
 *
 * Example (run on 8.7 all deployments + 8.8 saas only):
 *   const pred = matrix({
 *     include: { versions: ['8.7','8.8'], deployments: ['saas','self-managed'] },
 *     exclude: [{ version: '8.8', deployment: 'self-managed' }]
 *   })
 *   // In a test file (Vitest):
 *   // test.if(matrix(pred))('my test', () => { ...test logic })
 *
 * Example using allowAny (same intent):
 *   const pred = allowAny([{ version: '8.7' }, { version: '8.8', deployment: 'saas' }])
 *   test.if(matrix(pred))('my test', () => {})
 *
 * Debugging: set TEST_TAG_DEBUG=1 to log evaluation decisions.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TenancyTags = exports.SecurityTags = exports.DeploymentTags = exports.currentEnv = exports.TestTags = exports.VersionTags = void 0;
exports.matrix = matrix;
exports.allowAny = allowAny;
exports.tagged = tagged;
exports.VersionTags = {
    ['8.8']: '8.8',
    ['8.7']: '8.7',
};
const DeploymentModeTags = {
    saas: 'saas',
    selfManaged: 'self-managed',
    unitTest: 'unit-test',
};
exports.DeploymentTags = DeploymentModeTags;
const TenancyTags = {
    multiTenant: 'multi-tenant',
    singleTenant: 'single-tenant',
};
exports.TenancyTags = TenancyTags;
const SecurityTags = {
    secured: 'secured',
    unsecured: 'unsecured',
};
exports.SecurityTags = SecurityTags;
exports.TestTags = {
    ...exports.VersionTags,
    ...DeploymentModeTags,
    ...TenancyTags,
    ...SecurityTags,
};
const currentEnv = () => ({
    version: process.env.TEST_VERSION || '8.8',
    deployment: process.env.TEST_DEPLOYMENT || 'self-managed',
    tenancy: process.env.TEST_TENANCY || 'single-tenant',
    security: process.env.TEST_SECURITY || 'unsecured',
});
exports.currentEnv = currentEnv;
function matchesPattern(pattern, env) {
    return Object.entries(pattern).every(([k, v]) => env[k] === v);
}
// Generate predicate from matrix rules
function matrix(rules) {
    const includeKeys = Object.entries(rules.include);
    const expanded = [];
    if (includeKeys.length === 0) {
        // No explicit include lists given -> everything allowed unless excluded
        expanded.push({});
    }
    else {
        // Map plural include keys to exact environment property names
        const includeKeyToEnvKey = {
            versions: 'version',
            deployments: 'deployment',
            tenancy: 'tenancy',
            security: 'security',
        };
        const recur = (i, acc) => {
            if (i === includeKeys.length) {
                expanded.push(acc);
                return;
            }
            const [includeKey, values] = includeKeys[i];
            const envKey = includeKeyToEnvKey[includeKey];
            for (const val of values) {
                recur(i + 1, { ...acc, [envKey]: val });
            }
        };
        recur(0, {});
    }
    const env = (0, exports.currentEnv)();
    const debug = process.env.TEST_TAG_DEBUG === '1';
    const allowed = expanded.some((p) => matchesPattern(p, env));
    if (!allowed) {
        if (debug)
            console.log('[tagged][matrix] not in include set', { env, expanded });
        return false;
    }
    if (rules.exclude?.some((ex) => matchesPattern(ex, env))) {
        if (debug)
            console.log('[tagged][matrix] excluded', { env });
        return false;
    }
    if (debug)
        console.log('[tagged][matrix] allowed', { env });
    return true;
}
// Whitelist of partial environment tuples (OR logic)
function allowAny(patterns) {
    const env = (0, exports.currentEnv)();
    const debug = process.env.TEST_TAG_DEBUG === '1';
    const hit = patterns.some((p) => matchesPattern(p, env));
    if (debug)
        console.log('[tagged][allowAny]', { env, hit, patterns });
    return hit;
}
// Thin wrapper for clarity / future enhancement
function tagged(predicate) {
    return predicate((0, exports.currentEnv)());
}
//# sourceMappingURL=testTags.js.map